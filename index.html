<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Selection on Click/Touch</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            line-height: 1.6;
            font-size: 18px;
        }
        
        #content {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        span {
            margin-right: 5px;
        }
        
        #selected-word-display {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            min-height: 20px;
        }
        
        #toggle-button {
            margin-top: 20px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #toggle-button:hover {
            background-color: #45a049;
        }
        
        #status {
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Click or Touch to Select Words</h1>
    <p>Click or tap on any word to select it. You can also drag to select multiple words as usual.</p>
    
    <div id="content">
        <span>This is some English text.</span>
        <span>Esto es texto en español.</span>
        <span>这是中文文本。</span>
        <span>これは日本語のテキストです。</span>
        <span>هذا نص باللغة العربية.</span>
    </div>
    
    <div id="selected-word-display">
        <strong>Selected word will appear here</strong>
    </div>
    
    <button id="toggle-button">Toggle Quick Select Mode</button>
    <div id="status">Currently in Quick Select Mode: ON</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('content');
            const wordDisplay = document.getElementById('selected-word-display');
            const toggleButton = document.getElementById('toggle-button');
            const statusDiv = document.getElementById('status');
            
            // State variables
            let quickSelectEnabled = true;
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            let hasMoved = false;
            let isMouseDown = false;
            let mouseStartX = 0;
            let mouseStartY = 0;
            let mouseHasMoved = false;
            
            // Toggle quick select mode
            toggleButton.addEventListener('click', function() {
                quickSelectEnabled = !quickSelectEnabled;
                statusDiv.textContent = `Currently in Quick Select Mode: ${quickSelectEnabled ? 'ON' : 'OFF'}`;
            });
            
            // ====== MOBILE TOUCH HANDLING ======
            
            // Touch start
            container.addEventListener('touchstart', function(event) {
                if (!quickSelectEnabled) return;
                
                touchStartTime = new Date().getTime();
                const touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                hasMoved = false;
            });
            
            // Touch move
            container.addEventListener('touchmove', function(event) {
                if (!quickSelectEnabled) return;
                
                const touch = event.touches[0];
                const deltaX = Math.abs(touch.clientX - touchStartX);
                const deltaY = Math.abs(touch.clientY - touchStartY);
                
                // If moved more than threshold, mark as dragging
                if (deltaX > 10 || deltaY > 10) {
                    hasMoved = true;
                }
            });
            
            // Touch end
            container.addEventListener('touchend', function(event) {
                if (!quickSelectEnabled) return;
                
                const touchEndTime = new Date().getTime();
                const touchDuration = touchEndTime - touchStartTime;
                
                // If this was a tap (short duration, minimal movement)
                if (!hasMoved && touchDuration < 300) {
                    const touch = event.changedTouches[0];
                    
                    // Attempt to select the word
                    const success = selectWordAtPoint(touch.clientX, touch.clientY);
                    
                    // Only prevent default if we successfully selected a word
                    if (success) {
                        event.preventDefault();
                        
                        // Update the display with the current selection
                        updateSelectedDisplay();
                    }
                }
                // Otherwise, it was a drag or long press - let native behavior work
                else if (hasMoved) {
                    // Small delay to ensure the selection is complete
                    setTimeout(updateSelectedDisplay, 50);
                }
            });
            
            // ====== DESKTOP MOUSE HANDLING ======
            
            // Mouse down
            container.addEventListener('mousedown', function(event) {
                if (!quickSelectEnabled || event.button !== 0) return;
                
                isMouseDown = true;
                mouseStartX = event.clientX;
                mouseStartY = event.clientY;
                mouseHasMoved = false;
            });
            
            // Mouse move
            container.addEventListener('mousemove', function(event) {
                if (!isMouseDown) return;
                
                const deltaX = Math.abs(event.clientX - mouseStartX);
                const deltaY = Math.abs(event.clientY - mouseStartY);
                
                // If moved more than threshold, mark as dragging
                if (deltaX > 5 || deltaY > 5) {
                    mouseHasMoved = true;
                }
            });
            
            // Mouse up
            container.addEventListener('mouseup', function(event) {
                if (!quickSelectEnabled || !isMouseDown || event.button !== 0) {
                    isMouseDown = false;
                    return;
                }
                
                isMouseDown = false;
                
                // If it was a click (no significant movement)
                if (!mouseHasMoved) {
                    selectWordAtPoint(event.clientX, event.clientY);
                    updateSelectedDisplay();
                } else {
                    // It was a drag, update the display with the current selection
                    setTimeout(updateSelectedDisplay, 50);
                }
            });
            
            // Update the display based on current selection
            function updateSelectedDisplay() {
                const selection = window.getSelection();
                if (selection && selection.toString().trim() !== '') {
                    wordDisplay.innerHTML = `<strong>Selected:</strong> "${selection.toString()}"`;
                }
            }
            
            // Prevent mouse events from interfering with touch events
            container.addEventListener('click', function(event) {
                if (quickSelectEnabled && !mouseHasMoved) {
                    // We don't want to prevent default here anymore
                    // Since we want the native click behavior for selection highlighting
                }
            });
            
            // ====== WORD SELECTION FUNCTION ======
            
            function selectWordAtPoint(x, y) {
                // Find the element at the point
                const element = document.elementFromPoint(x, y);
                if (!element) return false;
                
                // Make sure we're working with text
                const textContainer = element.closest('span');
                if (!textContainer || !textContainer.textContent.trim()) return false;
                
                // Find which text node was clicked and where
                const textPosition = findTextPositionAtPoint(textContainer, x, y);
                if (!textPosition) return false;
                
                const { node, offset } = textPosition;
                const text = node.textContent;
                
                // Find word boundaries
                const startPos = findWordStart(text, offset);
                const endPos = findWordEnd(text, offset);
                
                try {
                    // Create and apply the selection
                    const range = document.createRange();
                    range.setStart(node, startPos);
                    range.setEnd(node, endPos);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Display the selected word
                    const selectedWord = text.substring(startPos, endPos);
                    wordDisplay.innerHTML = `<strong>Selected:</strong> "${selectedWord}"`;
                    
                    return true;
                } catch (e) {
                    console.error('Selection error:', e);
                    return false;
                }
            }
            
            // This function finds the exact text node and offset where the point is
            function findTextPositionAtPoint(container, x, y) {
                // Get all text nodes
                const textNodes = [];
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let node;
                while (node = walker.nextNode()) {
                    textNodes.push(node);
                }
                
                if (textNodes.length === 0) return null;
                
                // If there's just one text node, simplify the process
                if (textNodes.length === 1) {
                    return {
                        node: textNodes[0],
                        offset: findOffsetInTextNode(textNodes[0], x, y)
                    };
                }
                
                // For multiple text nodes, find which one contains the point
                for (let i = 0; i < textNodes.length; i++) {
                    const node = textNodes[i];
                    const range = document.createRange();
                    range.selectNodeContents(node);
                    const rect = range.getBoundingClientRect();
                    
                    // Check if point is inside this text node's rectangle
                    if (x >= rect.left && x <= rect.right && 
                        y >= rect.top && y <= rect.bottom) {
                        return {
                            node: node,
                            offset: findOffsetInTextNode(node, x, y)
                        };
                    }
                }
                
                // If we couldn't find a precise match, use the first text node
                return {
                    node: textNodes[0],
                    offset: findOffsetInTextNode(textNodes[0], x, y)
                };
            }
            
            // This function finds the offset within a text node
            function findOffsetInTextNode(textNode, x, y) {
                const text = textNode.textContent;
                
                // Empty text case
                if (!text || text.length === 0) return 0;
                
                // For very short text, check character by character
                if (text.length < 25) {
                    let bestOffset = 0;
                    let closestDistance = Infinity;
                    
                    for (let i = 0; i <= text.length; i++) {
                        const range = document.createRange();
                        range.setStart(textNode, 0);
                        range.setEnd(textNode, i);
                        const rect = range.getBoundingClientRect();
                        
                        // Find distance to this point
                        const distance = Math.abs(x - rect.right);
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            bestOffset = i;
                        }
                    }
                    
                    return bestOffset;
                }
                
                // For longer text, use binary search for efficiency
                let lo = 0;
                let hi = text.length;
                let mid, loRect, hiRect, midRect;
                
                // Initial bounds
                let range = document.createRange();
                range.setStart(textNode, 0);
                range.setEnd(textNode, 0);
                loRect = range.getBoundingClientRect();
                
                range = document.createRange();
                range.setStart(textNode, text.length);
                range.setEnd(textNode, text.length);
                hiRect = range.getBoundingClientRect();
                
                // If point is before the start or after the end
                if (x <= loRect.right) return 0;
                if (x >= hiRect.left) return text.length;
                
                // Binary search for the closest offset
                while (lo <= hi) {
                    mid = Math.floor((lo + hi) / 2);
                    
                    range = document.createRange();
                    range.setStart(textNode, 0);
                    range.setEnd(textNode, mid);
                    midRect = range.getBoundingClientRect();
                    
                    if (x <= midRect.right) {
                        hi = mid - 1;
                    } else {
                        lo = mid + 1;
                    }
                }
                
                // Refine to find the closest edge
                const finalOffset = lo;
                range = document.createRange();
                range.setStart(textNode, 0);
                range.setEnd(textNode, finalOffset);
                const finalRect = range.getBoundingClientRect();
                
                // If closer to previous character
                if (finalOffset > 0 && x < (finalRect.right + finalRect.left) / 2) {
                    return finalOffset - 1;
                }
                
                return finalOffset;
            }
            
            // Find the start of a word
            function findWordStart(text, position) {
                if (position <= 0) return 0;
                
                let pos = position;
                
                // Move backward until we find a word boundary
                while (pos > 0 && !/\s/.test(text.charAt(pos - 1))) {
                    pos--;
                }
                
                return pos;
            }
            
            // Find the end of a word
            function findWordEnd(text, position) {
                if (position >= text.length) return text.length;
                
                let pos = position;
                
                // Move forward until we find a word boundary
                while (pos < text.length && !/\s/.test(text.charAt(pos))) {
                    pos++;
                }
                
                return pos;
            }
            
            // Listen for selection changes from any source
            document.addEventListener('selectionchange', function() {
                updateSelectedDisplay();
            });
        });
    </script>
</body>
</html>
