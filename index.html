<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Selection on Click/Touch</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            line-height: 1.6;
            font-size: 18px;
        }
        
        #content {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        span {
            margin-right: 5px;
            cursor: pointer;
        }
        
        #selected-word-display {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            min-height: 20px;
        }
        
        #toggle-button {
            margin-top: 20px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #toggle-button:hover {
            background-color: #45a049;
        }
        
        #status {
            margin-top: 10px;
            font-style: italic;
        }

        .selected-word {
            background-color: rgba(255, 255, 0, 0.3);
        }
    </style>
</head>
<body>
    <h1>Click or Touch to Select Words</h1>
    <p>Click or tap on any word to select it. You can also drag to select multiple words as usual.</p>
    
    <div id="content">
        <span>This is some English text.</span>
        <span>Esto es texto en español.</span>
        <span>这是中文文本。</span>
        <span>これは日本語のテキストです。</span>
        <span>هذا نص باللغة العربية.</span>
    </div>
    
    <div id="selected-word-display">
        <strong>Selected word will appear here</strong>
    </div>
    
    <button id="toggle-button">Toggle Quick Select Mode</button>
    <div id="status">Currently in Quick Select Mode: ON</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('content');
            const wordDisplay = document.getElementById('selected-word-display');
            const toggleButton = document.getElementById('toggle-button');
            const statusDiv = document.getElementById('status');
            
            // State variables
            let quickSelectEnabled = true;
            let touchTimer = null;
            let lastTapTime = 0;
            
            // Toggle quick select mode
            toggleButton.addEventListener('click', function() {
                quickSelectEnabled = !quickSelectEnabled;
                statusDiv.textContent = `Currently in Quick Select Mode: ${quickSelectEnabled ? 'ON' : 'OFF'}`;
            });
            
            // ====== UNIVERSAL POINTER HANDLING (WORKS FOR MOUSE AND TOUCH) ======
            
            // Prevent default behavior for touch events in our container to avoid text selection conflicts
            container.addEventListener('touchstart', function(event) {
                if (!quickSelectEnabled) return;
                
                const now = Date.now();
                const timeSinceLastTap = now - lastTapTime;
                
                // If this is a double tap, let the browser handle it
                if (timeSinceLastTap < 300) {
                    return;
                }
                
                lastTapTime = now;
                
                // Clear any existing timer
                if (touchTimer) {
                    clearTimeout(touchTimer);
                }
                
                // We don't prevent default immediately to allow normal browser behavior
                // But we set up a timer to handle our custom selection
                touchTimer = setTimeout(() => {
                    const touch = event.touches[0];
                    handlePointerEvent(touch.clientX, touch.clientY);
                }, 10); // Small delay to let the browser register the touch
            }, { passive: false });
            
            // For normal click events
            container.addEventListener('click', function(event) {
                if (!quickSelectEnabled) return;
                handlePointerEvent(event.clientX, event.clientY);
            });
            
            // Main function to handle both mouse clicks and touch events
            function handlePointerEvent(x, y) {
                // Find the element and word at the pointer position
                const element = document.elementFromPoint(x, y);
                if (!element) return;
                
                // Make sure we're working with text inside our container
                if (!container.contains(element)) return;
                
                // Find the text span
                const textSpan = element.closest('span');
                if (!textSpan || !textSpan.textContent.trim()) return;
                
                // Get the word at the position
                const selectedInfo = getWordAtPosition(textSpan, x, y);
                if (!selectedInfo) return;
                
                // Apply the selection using the native selection API
                applySelection(selectedInfo.node, selectedInfo.startPos, selectedInfo.endPos);
                
                // Update the display with the selected word
                const selectedWord = selectedInfo.word;
                wordDisplay.innerHTML = `<strong>Selected:</strong> "${selectedWord}"`;
            }
            
            // Function to get the word at a specific position
            function getWordAtPosition(textContainer, x, y) {
                // Create a document range
                const range = document.caretRangeFromPoint(x, y);
                if (!range) return null;
                
                // Make sure the range is inside our text container
                if (!textContainer.contains(range.startContainer)) return null;
                
                // Get the text node
                const textNode = range.startContainer;
                if (textNode.nodeType !== Node.TEXT_NODE) return null;
                
                const text = textNode.textContent;
                const offset = range.startOffset;
                
                // Find word boundaries with improved algorithm
                const startPos = findWordStart(text, offset);
                const endPos = findWordEnd(text, offset);
                
                // Extract the selected word
                const selectedWord = text.substring(startPos, endPos);
                
                return {
                    node: textNode,
                    startPos: startPos,
                    endPos: endPos,
                    word: selectedWord
                };
            }
            
            // Apply selection to text
            function applySelection(node, startPos, endPos) {
                try {
                    // Create and apply the selection
                    const range = document.createRange();
                    range.setStart(node, startPos);
                    range.setEnd(node, endPos);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Add visual feedback even if native selection fails
                    highlightSelectedText(node, startPos, endPos);
                    
                    return true;
                } catch (e) {
                    console.error('Selection error:', e);
                    return false;
                }
            }
            
            // Enhanced word boundary detection for different languages
            function findWordStart(text, position) {
                if (position <= 0) return 0;
                
                let pos = position;
                
                // Handle different script types differently
                // For most scripts, spaces define word boundaries
                const spaceRegex = /\s/;
                
                // For scripts without spaces between words (like Chinese), use character boundaries
                const isCJK = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]/.test(text.charAt(pos));
                
                if (isCJK) {
                    // For CJK text, each character is considered a word
                    return pos;
                } else {
                    // For other scripts, look for word boundaries
                    while (pos > 0 && !spaceRegex.test(text.charAt(pos - 1)) && 
                           !isPunctuation(text.charAt(pos - 1))) {
                        pos--;
                    }
                }
                
                return pos;
            }
            
            // Find the end of a word with improved language support
            function findWordEnd(text, position) {
                if (position >= text.length) return text.length;
                
                let pos = position;
                
                // Handle different script types
                const spaceRegex = /\s/;
                
                // Check if this is CJK text
                const isCJK = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]/.test(text.charAt(pos));
                
                if (isCJK) {
                    // For CJK text, simply return the next position
                    return pos + 1;
                } else {
                    // For other scripts, look for word boundaries
                    while (pos < text.length && !spaceRegex.test(text.charAt(pos)) && 
                           !isPunctuation(text.charAt(pos))) {
                        pos++;
                    }
                }
                
                return pos;
            }
            
            // Helper function to check for punctuation
            function isPunctuation(char) {
                return /[.,\/#!$%\^&\*;:{}=\-_`~()\[\]"']/g.test(char);
            }
            
            // Add visual highlighting to ensure feedback even when native selection fails
            function highlightSelectedText(node, startPos, endPos) {
                const text = node.textContent;
                const selectedText = text.substring(startPos, endPos);
                
                // Create elements for the three parts of text
                const beforeText = text.substring(0, startPos);
                const afterText = text.substring(endPos);
                
                // Create a temporary container
                const tempSpan = document.createElement('span');
                
                // Add text before selection
                if (beforeText) {
                    tempSpan.appendChild(document.createTextNode(beforeText));
                }
                
                // Add selected text with highlight
                const highlightSpan = document.createElement('span');
                highlightSpan.className = 'selected-word';
                highlightSpan.textContent = selectedText;
                tempSpan.appendChild(highlightSpan);
                
                // Add text after selection
                if (afterText) {
                    tempSpan.appendChild(document.createTextNode(afterText));
                }
                
                // Replace the text node's parent content
                const parentElement = node.parentElement;
                const tempFragment = document.createDocumentFragment();
                while (tempSpan.firstChild) {
                    tempFragment.appendChild(tempSpan.firstChild);
                }
                
                // Remember the original content
                const originalContent = parentElement.innerHTML;
                
                // Replace with our highlighted content
                parentElement.innerHTML = '';
                parentElement.appendChild(tempFragment);
                
                // Restore original content after a brief delay
                // This ensures our highlighting is visible even if native selection gets cleared
                setTimeout(() => {
                    // Only restore if we aren't in the middle of another selection
                    const selection = window.getSelection();
                    if (!selection || selection.toString().trim() === '') {
                        parentElement.innerHTML = originalContent;
                    }
                }, 1000);
            }
            
            // Listen for selection changes from any source
            document.addEventListener('selectionchange', function() {
                const selection = window.getSelection();
                if (selection && selection.toString().trim() !== '') {
                    wordDisplay.innerHTML = `<strong>Selected:</strong> "${selection.toString()}"`;
                }
            });
            
            // Handle touchend to allow scrolling
            document.addEventListener('touchend', function() {
                if (touchTimer) {
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
            });
        });
    </script>
</body>
</html>
