<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Word Tap Picker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    #text-container {
      padding: 20px;
      font-size: 18px;
      line-height: 1.6;
       user-select: text;
        -webkit-user-modify: read-only;
    }
    #output {
      margin-top: 20px;
      font-size: 20px;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <div id="text-container" contenteditable="true">
    <span>Click here to begin. </span>
    <span>यह एक परीक्षण वाक्य है। </span>
    <span>这是一个测试句子。 </span>
    <span>هذه جملة اختبار. </span>
  </div>

  <div id="output">Selected word: <span id="selected-word"></span></div>

  <script>
    const container = document.getElementById('text-container');

    function getWordInfoAtPoint(x, y) {
      const node = document.elementFromPoint(x, y);
      if (!node) return null;

      // Find deepest text node
      let textNode = null;
      const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
      while (walker.nextNode()) {
        textNode = walker.currentNode;
        break;
      }

      if (!textNode) return null;

      const range = document.createRange();
      range.selectNodeContents(textNode);

      const text = textNode.textContent;
      if (!text || text.trim() === '') return null;

      const rects = [];
      for (let i = 0; i < text.length; i++) {
        range.setStart(textNode, i);
        range.setEnd(textNode, i + 1);
        const rect = range.getBoundingClientRect();
        rects.push({ index: i, rect });
      }

      const hit = rects.find(r =>
        x >= r.rect.left &&
        x <= r.rect.right &&
        y >= r.rect.top &&
        y <= r.rect.bottom
      );

      if (!hit) return null;

      const segmenter = new Intl.Segmenter('und', { granularity: 'word' });
      const segments = [...segmenter.segment(text)];

      for (const segment of segments) {
        const start = segment.index;
        const end = start + segment.segment.length;
        if (hit.index >= start && hit.index < end) {
          return {
            word: segment.segment,
            start,
            end,
            textNode
          };
        }
      }

      return null;
    }

    function handleTapOrClick(e) {
      e.preventDefault();
      const x = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
      const y = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
      console.log('HERE1');
      if (x == null || y == null) return;
      console.log('HERE2');
      const info = getWordInfoAtPoint(x, y);
      console.log('HERE3');
      if (info) {
        document.getElementById('selected-word').textContent = info.word;
        console.log('Selected word:', info.word);

        // Visibly select the word
        const selection = window.getSelection();
        selection.removeAllRanges();
        const range = document.createRange();
        range.setStart(info.textNode, info.start);
        range.setEnd(info.textNode, info.end);
        setTimeout(() => {
            selection.addRange(range);
            // document.dispatchEvent(new Event('selectionChange'));
            console.log('HERE4',window.getSelection().toString());
        }, 50);
      }
    }

    container.addEventListener('click', handleTapOrClick);
    container.addEventListener('touchend', handleTapOrClick);

    document.addEventListener('selectionchange', (e) => {
      console.log('HERE5', window.getSelection().toString());
    });
    // Reference to an output container, use 'pre' styling for JSON output
  var output = document.createElement('pre');
  document.body.appendChild(output);
  
  // Reference to native method(s)
  var oldLog = console.log;
  
  console.log = function( ...items ) {
  
      // Call native method first
      oldLog.apply(this,items);
  
      // Use JSON to transform objects, all others display normally
      items.forEach( (item,i)=>{
          items[i] = (typeof item === 'object' ? JSON.stringify(item,null,4) : item);
      });
      output.innerHTML += items.join(' ') + '<br />';
  
  };
  
  // You could even allow Javascript input...
  function consoleInput( data ) {
      // Print it to console as typed
      console.log( data + '<br />' );
      try {
          console.log( eval( data ) );
      } catch (e) {
          console.log( e.stack );
      }
  }
  </script>

</body>
</html>
